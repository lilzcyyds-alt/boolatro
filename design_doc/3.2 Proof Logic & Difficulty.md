# 3.2 Proof Logic & Difficulty

本文件记录了游戏中实现的逻辑证明规则、难度分级系统以及任务生成逻辑。

## 逻辑证明规则 (Logical Rules)

系统当前支持以下自然演绎（Natural Deduction）规则：

| 规则代码 | 名称 | 说明 |
| :--- | :--- | :--- |
| `reit` | 重复 (Reiteration) | 引用之前已有的行，其内容必须完全一致。 |
| `&elim` | 合取消除 (& Elimination) | 从 `A & B` 中提取出 `A` 或 `B`。 |
| `&intro` | 合取引入 (& Introduction) | 由 `A` 和 `B` 构造出 `A & B`。 |
| `~elim` | 双重否定消除 (~ Elimination) | 从 `~~A` 得到 `A`。 |
| `~intro` | 双重否定引入 (~ Introduction) | 由 `A` 得到 `~~A`。 |

### 验证逻辑
- **WFF (Well-Formed Formula)**: 所有公式必须通过合式公式检查（支持原子命题 A-T，操作符 &, v, ~）。
- **Normalization**: 验证时会自动忽略空格，并对括号进行标准化处理，以确保逻辑等价性。

## 难度分级 (Difficulty Tiers)

任务生成器 (`ProofTaskGenerator`) 使用以下维度定义难度：

### 1. 难度等级 (Difficulty)
- **Small**: 基础任务，公式结构简单。
- **Big**: 进阶任务，包含更多层级的逻辑嵌套。
- **Boss**: 复杂任务，包含深层嵌套或多种负面修饰符。

### 2. 电路复杂度 (Circuit Level)
- **Level 1-3**: 限制了公式中操作符的数量。
- **Level 4+**: 允许更复杂的逻辑组合。

### 3. 公式类型 (Formula Types)
- **Simple**: 如 `P & Q`, `~~P & Q`。
- **Complex**: 
  - `P & (Q & R)`
  - `~~(P & (Q & R))`
  - 甚至包含三重否定修饰的任务。

## 任务生成流程
1. 确定当前盲注要求的 `Difficulty` 和 `CircuitLevel`。
2. 调用 `generateTask` 随机选择一个匹配的公式模板。
3. 随机填充原子命题（P, Q, R, S, T）。
4. 通过 `ProofValidator` 进行自检，确保生成的任务是合法的。
